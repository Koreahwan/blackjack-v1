split 구현을 위해 리팩토링하기.

제공해주신 코드를 바탕으로 **Blackjack Split(스플릿)** 기능을 구현하기 위한 **개발 로직과 방향성**을 정리해 드립니다. 코드를 직접 작성하신다고 하셨으니, 구체적인 코드보다는 **어떤 변수를 어떻게 관리해야 하고, 흐름을 어떻게 제어해야 하는지**에 초점을 맞추겠습니다.

---

### 1. 핵심 데이터 구조 변경 (1차원 → 2차원 배열 관리)

현재 `playerhands`는 2차원 배열로 선언되어 있지만, 실제 `hit`나 `stand` 함수 내부(현재 코드상의 `playerhand` 오타 추정 부분)에서는 단일 패처럼 처리되고 있습니다. 스플릿을 위해서는 **현재 플레이어가 '몇 번째 패'를 플레이 중인지**를 아는 것이 핵심입니다.

* **필요 변수 추가:**
* `currentHandIndex`: 현재 플레이어가 조작 중인 손이 첫 번째인지(0), 두 번째인지(1)를 가리키는 인덱스 변수가 필요합니다. (초기값 0)


* **배열 접근 방식 변경:**
* 모든 `Playeraction` 함수(Hit, Stand 등)에서 카드를 참조할 때 `playerhands[currentHandIndex]` 형태로 접근해야 합니다.



### 2. `Playeraction.split()` 내부 로직 설계

스플릿 버튼을 눌렀을 때 수행해야 할 논리적 순서입니다.

1. **자금 확인:** `sessionStorage.wallet`이 현재 `betmoney`만큼 추가로 지불 가능한지 확인합니다. (불가능하면 리턴)
2. **추가 베팅:** `betmoney`만큼 지갑에서 추가로 차감합니다. (단, 결과 계산을 위해 각 손(Hand)마다 베팅액을 따로 저장하거나, 단순히 `betmoney` 변수를 유지하고 결과 처리 시 횟수를 곱할지 결정해야 합니다. 보통은 판돈이 2배가 됩니다.)
3. **카드 분배 (핵심):**
* `playerhands[0]`에 있는 두 번째 카드를 `pop()` 합니다.
* `playerhands` 배열에 새로운 배열 `[]`을 `push` 하여 두 번째 손(`playerhands[1]`)을 만듭니다.
* `pop`한 카드를 `playerhands[1]`에 넣습니다.
* **카드 보충:** `gamedeck`에서 카드를 두 장 뽑아 `playerhands[0]`과 `playerhands[1]`에 각각 한 장씩 더해줍니다. (각 손이 2장이 되도록)


4. **UI 변경:**
* 기존의 `pcardspace` 하나로는 부족합니다. DOM 조작을 통해 화면을 좌우(혹은 상하)로 나누어 **Hand 1 영역**과 **Hand 2 영역**을 동적으로 생성해야 합니다.
* 각 영역에 해당 카드의 이미지를 다시 렌더링합니다.



### 3. 게임 진행 흐름 (State Machine) 변경

스플릿 상태에서는 `HIT`와 `STAND`의 동작이 달라져야 합니다.

* **HIT 로직:**
* 무조건 `playerhands[currentHandIndex]`에 카드를 추가합니다.
* **Bust(21 초과) 발생 시:** 게임을 바로 끝내지 않습니다.
* 만약 `currentHandIndex`가 0(첫 번째 손)이라면: "Bust" 메시지를 해당 손에 띄우고, `currentHandIndex`를 1로 증가시켜 두 번째 손으로 넘어갑니다.
* 만약 `currentHandIndex`가 1(마지막 손)이라면: 딜러 턴으로 넘어가거나 결과를 처리합니다.




* **STAND 로직:**
* 만약 `currentHandIndex`가 0이라면: 첫 번째 손을 완료한 것이므로, `currentHandIndex`를 1로 증가시키고 포커스(UI 강조 등)를 두 번째 손으로 옮깁니다.
* 만약 `currentHandIndex`가 1이라면: 플레이어의 모든 턴이 끝났으므로 **딜러의 턴(`dealerTurn`)** 함수를 호출합니다.



### 4. 딜러의 행동 및 승패 판정 (Dealer Logic & Result)

딜러는 플레이어의 손이 몇 개든 상관없이 **자신의 룰(16 이하 히트, 17 이상 스테이)**대로 한 번만 플레이합니다. 그 후 결과를 각각 비교합니다.

1. **딜러 플레이:** 플레이어의 모든 손이 Bust가 아닌 이상 딜러는 카드를 받습니다. (모든 손이 Bust면 딜러는 카드 받을 필요 없이 플레이어 패배)
2. **결과 정산 루프:**
* `playerhands` 배열을 `forEach` 혹은 `for`문으로 순회합니다.
* **Hand 0 vs 딜러:** 승/무/패 계산 -> 지갑 업데이트.
* **Hand 1 vs 딜러:** 승/무/패 계산 -> 지갑 업데이트.
* 각 손의 결과를 합산하여 최종 획득/손실 금액을 보여줍니다.



### 5. UI/UX 구현 팁

* **포커스 표시:** 현재 플레이어가 조작 중인 손(`currentHandIndex`에 해당하는 영역)에 테두리 색상을 다르게 하거나 화살표를 표시하여, 어느 쪽에 카드를 받을지 명확히 해주는 것이 좋습니다.
* **점수판 분리:** `psum`도 `psum1`, `psum2` 처럼 분리하여 각 손의 합계를 따로 보여줘야 합니다.

### 요약: 코드 수정 로드맵

1. **변수:** `currentHandIndex = 0` 전역 변수 추가.
2. **Split 함수:** `playerhands` 배열 쪼개기 + `betmoney` 추가 차감 + UI(div) 2개로 분할.
3. **Hit 함수:** `playerhands[currentHandIndex]` 대상 수행. Bust 시 다음 손으로 넘기기(`currentHandIndex++`).
4. **Stand 함수:** 현재 손 종료. 다음 손이 있으면 `currentHandIndex++`, 없으면 딜러 턴 시작.
5. **결과 함수:** `playerhands`의 길이만큼 반복문을 돌며 딜러와 각각 비교.

이 방향대로 `game.js`의 구조를 잡으시면 스플릿 기능을 성공적으로 구현하실 수 있을 것입니다. 특히 현재 코드에서 `playerhand`와 `playerhands` 변수명이 혼용(오타 가능성)되고 있는데, 이를 `playerhands[index]` 형태로 명확히 통일하는 작업부터 시작하시는 것을 추천합니다.